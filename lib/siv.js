// Generated by CoffeeScript 1.9.1
var indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

(function(root, factory) {
  if (('function' === typeof define) && (define.amd != null)) {
    return define(['chrono', 'lodash'], factory);
  } else if (typeof exports !== "undefined" && exports !== null) {
    return module.exports = factory(require('chrono-node'), require('lodash'));
  } else {
    return root.siv = factory(root.chrono, root._);
  }
})(this, function(chrono, _) {
  var siv;
  siv = {};
  siv.limit = function(table, query) {
    var parsed;
    if (query.limit == null) {
      return table;
    }
    parsed = parseInt(query.limit, 10);
    if (isNaN(parsed)) {
      return new siv.Error({
        limit: 'must be an integer'
      }, table);
    }
    if (siv.isError(table)) {
      return table;
    }
    return table.limit(parsed);
  };
  siv.offset = function(table, query) {
    var parsed;
    if (query.offset == null) {
      return table;
    }
    parsed = parseInt(query.offset, 10);
    if (isNaN(parsed)) {
      return new siv.Error({
        offset: 'must be an integer'
      }, table);
    }
    if (siv.isError(table)) {
      return table;
    }
    return table.offset(parsed);
  };
  siv.order = function(table, query, options) {
    var asc, error, order, ref, ref1;
    if (!(0 < (options != null ? (ref = options.allow) != null ? ref.length : void 0 : void 0))) {
      throw new Error('`options.allow` must be an array with at least one element');
    }
    if ((options.asc != null) && (options.order == null)) {
      throw new Error('if `options.asc` is set then `options.order` must also be set');
    }
    if (siv.isError(table)) {
      error = table;
    }
    if (query.order != null) {
      if (query.order === '') {
        error = new siv.Error({
          order: 'must not be blank if set'
        }, error);
      } else if (!((ref1 = query.order, indexOf.call(options.allow, ref1) >= 0) || (query.order === options["default"]))) {
        error = new siv.Error({
          order: 'ordering by this column is not allowed'
        }, error);
      } else {
        order = query.order;
      }
    } else {
      order = options.order;
    }
    if (query.asc != null) {
      if ((order == null) && (error == null)) {
        error = new siv.Error({
          asc: 'if `asc` is set then `order` must also be set'
        }, error);
      } else if (query.asc === 'true') {
        asc = true;
      } else if (query.asc === 'false') {
        asc = false;
      } else {
        error = new siv.Error({
          asc: 'must be either the string `true` or the string `false`'
        }, error);
      }
    } else {
      if (options.asc != null) {
        asc = options.asc;
      } else {
        asc = true;
      }
    }
    if (error != null) {
      return error;
    }
    if (order != null) {
      return table.order(order + ' ' + (asc ? 'ASC' : 'DESC'));
    }
    return table;
  };
  siv.nullable = function(table, query, column) {
    var condition, json, ref, ref1, value;
    if (!(('string' === typeof column) && (column !== ''))) {
      throw new Error('column must be a non-blank string');
    }
    value = query != null ? (ref = query.where) != null ? ref[column] : void 0 : void 0;
    if ((value != null ? value["null"] : void 0) == null) {
      return table;
    }
    if ((ref1 = value["null"]) !== 'true' && ref1 !== 'false') {
      json = {
        where: {}
      };
      json.where[column] = {
        "null": 'must be either the string `true` or the string `false`'
      };
      return new siv.Error(json, table);
    }
    if (siv.isError(table)) {
      return table;
    }
    condition = {};
    condition[column] = {
      $null: value["null"] === 'true'
    };
    return table.where(condition);
  };
  siv.integer = function(table, query, column) {
    var condition, error, json, parsed, ref, t, value;
    if (!(('string' === typeof column) && (column !== ''))) {
      throw new Error('column must be a non-blank string');
    }
    value = query != null ? (ref = query.where) != null ? ref[column] : void 0 : void 0;
    if (value == null) {
      return table;
    }
    if ('string' === typeof value) {
      parsed = parseInt(value, 10);
      if (isNaN(parsed)) {
        json = {
          where: {}
        };
        json.where[column] = 'must be parsable as an integer';
        return new siv.Error(json, table);
      }
      if (siv.isError(table)) {
        return table;
      }
      condition = {};
      condition[column] = parsed;
      return table.where(condition);
    }
    if ('object' !== typeof value) {
      return table;
    }
    if (siv.isError(table)) {
      error = table;
    }
    t = table;
    Object.keys(value).forEach(function(key) {
      var criterionKey, integers;
      if (key === 'in' || key === 'notin') {
        if (!Array.isArray(value[key])) {
          json = {
            where: {}
          };
          json.where[column] = {};
          json.where[column][key] = 'must be an array';
          error = new siv.Error(json, error);
          return;
        }
        if (!(value[key].length > 0)) {
          json = {
            where: {}
          };
          json.where[column] = {};
          json.where[column][key] = 'must not be empty';
          error = new siv.Error(json, error);
          return;
        }
        integers = [];
        _.forEach(value[key], function(item, index) {
          parsed = parseInt(item, 10);
          if (isNaN(parsed)) {
            json = {
              where: {}
            };
            json.where[column] = {};
            json.where[column][key] = {};
            json.where[column][key][index] = 'must be parsable as an integer';
            error = new siv.Error(json, error);
            return;
          }
          return integers.push(parsed);
        });
        if (error != null) {
          return;
        }
        condition = {};
        condition[column] = {};
        criterionKey = key === 'in' ? '$in' : '$nin';
        condition[column][criterionKey] = integers;
        t = t.where(condition);
        return;
      }
      parsed = parseInt(value[key], 10);
      if (isNaN(parsed)) {
        json = {
          where: {}
        };
        json.where[column] = {};
        json.where[column][key] = 'must be parsable as an integer';
        error = new siv.Error(json, error);
      }
      if (error != null) {
        return;
      }
      switch (key) {
        case 'equals':
          condition = {};
          condition[column] = parsed;
          return t = t.where(condition);
        case 'notequals':
          condition = {};
          condition[column] = {
            $ne: parsed
          };
          return t = t.where(condition);
        case 'lt':
          condition = {};
          condition[column] = {
            $lt: parsed
          };
          return t = t.where(condition);
        case 'lte':
          condition = {};
          condition[column] = {
            $lte: parsed
          };
          return t = t.where(condition);
        case 'gt':
          condition = {};
          condition[column] = {
            $gt: parsed
          };
          return t = t.where(condition);
        case 'gte':
          condition = {};
          condition[column] = {
            $gte: parsed
          };
          return t = t.where(condition);
      }
    });
    if (error != null) {
      return error;
    }
    return t;
  };
  siv.string = function(table, query, column) {
    var condition, error, ref, t, value;
    if (!(('string' === typeof column) && (column !== ''))) {
      throw new Error('column must be a non-blank string');
    }
    value = query != null ? (ref = query.where) != null ? ref[column] : void 0 : void 0;
    if (value == null) {
      return table;
    }
    if ('string' === typeof value) {
      condition = {};
      condition[column] = value;
      if (siv.isError(table)) {
        return table;
      }
      return table.where(condition);
    }
    if ('object' !== typeof value) {
      return table;
    }
    if (siv.isError(table)) {
      error = table;
    }
    t = table;
    Object.keys(value).forEach(function(key) {
      var criterionKey, json;
      if (key === 'in' || key === 'notin') {
        if (!Array.isArray(value[key])) {
          json = {
            where: {}
          };
          json.where[column] = {};
          json.where[column][key] = 'must be an array';
          error = new siv.Error(json, error);
          return;
        }
        if (!(value[key].length > 0)) {
          json = {
            where: {}
          };
          json.where[column] = {};
          json.where[column][key] = 'must not be empty';
          error = new siv.Error(json, error);
          return;
        }
        if (error != null) {
          return;
        }
        condition = {};
        condition[column] = {};
        criterionKey = key === 'in' ? '$in' : '$nin';
        condition[column][criterionKey] = value[key];
        t = t.where(condition);
        return;
      }
      if (error != null) {
        return;
      }
      switch (key) {
        case 'equals':
          return t = t.where(column + " = ?", value[key]);
        case 'notequals':
          return t = t.where(column + " != ?", value[key]);
        case 'contains':
          return t = t.where(column + " ILIKE '%' || ? || '%'", value[key]);
        case 'notcontains':
          return t = t.where(column + " NOT ILIKE '%' || ? || '%'", value[key]);
        case 'begins':
          return t = t.where(column + " ILIKE ? || '%'", value[key]);
        case 'notbegins':
          return t = t.where(column + " NOT ILIKE ? || '%'", value[key]);
        case 'ends':
          return t = t.where(column + " ILIKE '%' || ?", value[key]);
        case 'notends':
          return t = t.where(column + " NOT ILIKE '%' || ?", value[key]);
      }
    });
    if (siv.isError(error)) {
      return error;
    }
    return t;
  };
  siv.boolean = function(table, query, column) {
    var condition, json, ref, value;
    if (!(('string' === typeof column) && (column !== ''))) {
      throw new Error('column must be a non-blank string');
    }
    value = query != null ? (ref = query.where) != null ? ref[column] : void 0 : void 0;
    if (value == null) {
      return table;
    }
    if ('string' !== typeof value) {
      return table;
    }
    if (value !== 'true' && value !== 'false') {
      json = {
        where: {}
      };
      json.where[column] = 'must be either the string `true` or the string `false`';
      return new siv.Error(json, table);
    }
    if (siv.isError(table)) {
      return table;
    }
    condition = {};
    condition[column] = value === 'true';
    return table.where(condition);
  };
  siv.date = function(table, query, column, referenceDate) {
    var condition, json, ref, result, results, t, value;
    if (!(('string' === typeof column) && (column !== ''))) {
      throw new Error('column must be a non-blank string');
    }
    if (referenceDate == null) {
      referenceDate = new Date();
    }
    value = query != null ? (ref = query.where) != null ? ref[column] : void 0 : void 0;
    if (value == null) {
      return table;
    }
    if ('string' === typeof value) {
      results = chrono.parse(value, referenceDate);
      result = results[0];
      if (result == null) {
        json = {
          where: {}
        };
        json.where[column] = 'cant parse a date from the string';
        return new siv.Error(json, table);
      }
      if (siv.isError(table)) {
        return table;
      }
      condition = {};
      if (result.end == null) {
        condition[column] = result.start.date();
        return table.where(condition);
      }
      condition[column] = {
        gte: result.start.date(),
        lte: result.end.date()
      };
      return table.where(condition);
    }
    if ('object' !== typeof value) {
      return table;
    }
    t = table;
    return t;
  };
  siv.inherits = function(constructor, superConstructor) {
    var proxyConstructor;
    if ('function' === typeof Object.create) {
      constructor.prototype = Object.create(superConstructor.prototype);
      return constructor.prototype.constructor = constructor;
    } else {
      proxyConstructor = function() {};
      proxyConstructor.prototype = superConstructor.prototype;
      constructor.prototype = new proxyConstructor;
      return constructor.prototype.constructor = constructor;
    }
  };
  siv.Error = function(json, previous) {
    this.name = 'SivError';
    if (siv.isError(previous)) {
      this.json = _.merge({}, previous.json, json);
    } else {
      this.json = json;
    }
    this.message = JSON.stringify(this.json);
    if (Error.captureStackTrace != null) {
      Error.captureStackTrace(this, this.constructor);
    }
  };
  siv.inherits(siv.Error, Error);
  siv.isError = function(possiblyError) {
    return possiblyError instanceof siv.Error;
  };
  return siv;
});
